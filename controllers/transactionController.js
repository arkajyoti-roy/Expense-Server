const Transaction = require("../models/transaction");
const RecurringTransaction = require("../models/RecurringTransaction");
const Budget = require("../models/budget");
const mongoose = require("mongoose");

// ➕ Add Transaction with Budget Enforcement
const addTransaction = async (req, res) => {
  try {
    const { type, amount, description, date } = req.body;
    const userId = req.user.userId;

    if (!["credit", "debit"].includes(type)) {
      return res.status(400).json({ message: "Type must be credit or debit." });
    }

    if (!amount || Number(amount) <= 0) {
      return res.status(400).json({ message: "Amount must be a positive number." });
    }

    const txnDate = date ? new Date(date) : new Date();
    const monthKey = txnDate.toISOString().slice(0, 7); // e.g. "2024-07"

    const budget = await Budget.findOne({ userId, month: monthKey });
    if (!budget) {
      return res.status(403).json({ message: "Monthly budget not set." });
    }

    if (type === "debit" && Number(amount) > budget.currentBalance) {
      return res.status(400).json({ message: "Insufficient balance." });
    }

    const transaction = await Transaction.create({
      userId,
      type,
      amount: Number(amount),
      description,
      date: txnDate,
      month: monthKey
    });

    const newBalance =
      type === "debit"
        ? budget.currentBalance - Number(amount)
        : budget.currentBalance + Number(amount);

    await Budget.updateOne(
      { userId, month: monthKey },
      { currentBalance: newBalance }
    );

    res.status(201).json(transaction);
  } catch (err) {
    res.status(500).json({ message: "Transaction failed", error: err.message });
  }
};


// 📤 Get Monthly Transactions + Summary
const getTransactions = async (req, res) => {
  try {
    const userId = req.user.userId;
    const today = new Date();
    const dayOfMonth = today.getDate();
    const dayOfWeek = today.toLocaleDateString("en-US", { weekday: "long" });
    const monthKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}`;
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

    // Fetch all needed data concurrently
    const [transactions, budget, recurringRules] = await Promise.all([
      Transaction.find({ userId, date: { $gte: startOfMonth, $lte: endOfMonth } }),
      Budget.findOne({ userId, month: monthKey }),
      RecurringTransaction.find({ userId })
    ]);

    const openingBalance = budget?.openingBalance || 0;

    const totalCredit = transactions
      .filter(tx => tx.type === "credit")
      .reduce((sum, tx) => sum + tx.amount, 0);

    const totalDebit = transactions
      .filter(tx => tx.type === "debit")
      .reduce((sum, tx) => sum + tx.amount, 0);

    let totalRecurringCredit = 0;
    let totalRecurringDebit = 0;

    const virtualTransactions = [];

    // Generate virtual recurring transactions
    for (const rule of recurringRules) {
      const isDue =
        (rule.frequency === "monthly" && rule.startsOn.getDate() <= dayOfMonth) ||
        (rule.frequency === "weekly" && rule.weeklyDay === dayOfWeek);

      if (!isDue) continue;

      const virtualDesc = `Recurring: ${rule.title}`.trim();
      const virtualType = (rule.type || "").trim().toLowerCase();
      const virtualAmount = rule.amount;

      const alreadyExists = transactions.some(tx =>
        tx.description?.trim() === virtualDesc &&
        tx.amount === virtualAmount &&
        (tx.type || "").trim().toLowerCase() === virtualType &&
        tx.date.getMonth() === today.getMonth() &&
        tx.date.getFullYear() === today.getFullYear()
      );

      if (!alreadyExists) {
        if (virtualType === "debit") totalRecurringDebit += virtualAmount;
        else totalRecurringCredit += virtualAmount;

        virtualTransactions.push({
          _id: `virtual-${rule._id}`,
          userId,
          type: rule.type,
          amount: rule.amount,
          description: virtualDesc,
          date: today,
          isAutoGenerated: true
        });
      }
    }

    const allTransactions = [...transactions, ...virtualTransactions].sort(
      (a, b) => new Date(a.date) - new Date(b.date)
    );

    const netBalance =
      openingBalance + totalCredit + totalRecurringCredit - totalDebit - totalRecurringDebit;

    res.status(200).json({
      transactions: allTransactions,
      recurringRules,
      openingBalance,
      totalCredit,
      totalDebit: totalDebit + totalRecurringDebit,
      totalRecurring: totalRecurringCredit + totalRecurringDebit,
      netBalance
    });
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch transactions", error: err.message });
  }
};




// ✏️ Update Transaction (with balance adjustment)
const updateTransaction = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { id } = req.params;
    const newData = req.body;

    const original = await Transaction.findOne({ _id: id, userId });
    if (!original) {
      return res.status(404).json({ message: "Transaction not found." });
    }

    const monthKey = original.month || new Date(original.date).toISOString().slice(0, 7);
    const budget = await Budget.findOne({ userId, month: monthKey });

    if (!budget) {
      return res.status(403).json({ message: "Budget not found for this month." });
    }

    // Reverse old transaction effect
    let tempBalance =
      original.type === "debit"
        ? budget.currentBalance + original.amount
        : budget.currentBalance - original.amount;

    // Apply new transaction effect
    const newAmount = Number(newData.amount);
    const newType = newData.type;

    if (newType === "debit" && newAmount > tempBalance) {
      return res.status(400).json({ message: "Insufficient balance after update." });
    }

    tempBalance =
      newType === "debit"
        ? tempBalance - newAmount
        : tempBalance + newAmount;

    const updatedTxn = await Transaction.findOneAndUpdate(
      { _id: id, userId },
      {
        ...newData,
        amount: newAmount
      },
      { new: true }
    );

    await Budget.updateOne(
      { userId, month: monthKey },
      { currentBalance: tempBalance }
    );

    res.status(200).json(updatedTxn);
  } catch (err) {
    res.status(500).json({ message: "Update failed", error: err.message });
  }
};


// 🗑 Delete Transaction (with budget restore)
const deleteTransaction = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { id } = req.params;

    const transaction = await Transaction.findOneAndDelete({ _id: id, userId });
    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found." });
    }

    const budget = await Budget.findOne({ userId, month: transaction.month });
    if (budget) {
      const restoredBalance =
        transaction.type === "debit"
          ? budget.currentBalance + transaction.amount
          : budget.currentBalance - transaction.amount;

      await Budget.updateOne(
        { userId, month: transaction.month },
        { currentBalance: restoredBalance }
      );
    }

    res.status(200).json({ message: "Transaction deleted." });
  } catch (err) {
    res.status(500).json({ message: "Delete failed", error: err.message });
  }
};

// 📅 Get Last 6 Months Transactions + Recurring
const getLastSixMonthsTransactions = async (req, res) => {
  try {
    const userId = req.user.userId;
    const now = new Date();
    const sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 5, 1);

    const [transactions, recurring] = await Promise.all([
      Transaction.find({ userId, date: { $gte: sixMonthsAgo, $lte: now } }).sort({ date: 1 }),
      RecurringTransaction.find({ userId })
    ]);

    res.status(200).json({ transactions, recurring });
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch 6-month history", error: err.message });
  }
};

// 🔍 Custom Range Summary
const getCustomTransactionsWithSummary = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { start, end } = req.query;

    if (!start || !end) {
      return res.status(400).json({ message: "Start and end dates are required." });
    }

    const startDate = new Date(start);
    const endDate = new Date(end);
    endDate.setDate(endDate.getDate() + 1); // include final day

    const transactions = await Transaction.find({
      userId,
      date: { $gte: startDate, $lt: endDate }
    }).sort({ date: 1 });

    const [creditTotal, debitTotal, recurring] = await Promise.all([
      Transaction.aggregate([
        {
          $match: {
            userId: new mongoose.Types.ObjectId(userId),
            date: { $gte: startDate, $lt: endDate },
            type: "credit"
          }
        },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ]),
      Transaction.aggregate([
        {
          $match: {
            userId: new mongoose.Types.ObjectId(userId),
            date: { $gte: startDate, $lt: endDate },
            type: "debit"
          }
        },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ]),
      RecurringTransaction.find({ userId })
    ]);

    res.status(200).json({
      transactions,
      recurring,
      summary: {
        totalCredit: creditTotal[0]?.total || 0,
        totalDebit: debitTotal[0]?.total || 0,
        netBalance: (creditTotal[0]?.total || 0) - (debitTotal[0]?.total || 0)
      }
    });
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch custom transactions", error: err.message });
  }
};
// Export all functions
module.exports = {  
  addTransaction,
  getTransactions,
  updateTransaction,
  deleteTransaction,
  getLastSixMonthsTransactions,
  getCustomTransactionsWithSummary
};  